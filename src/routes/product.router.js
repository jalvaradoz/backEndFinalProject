import express from 'express'
import productModel from "../models/product.model.js"

const productRouter = express.Router()

export const getProducts = async () => {
    try {
        return await productModel.find()
    } catch (error) {
        res.status(500).json({ error: 'Error fetching products', error })
        return []
    }
}

// Helper function to handle pagination and filtering
export const getPaginatedProducts = async (query, page, limit, sort) => {
    try {
        const options = {
            page: parseInt(page, 10),
            limit: parseInt(limit, 10),
            sort: sort ? { price: sort } : {},
        }

        // Filter based on category or stock availability
        const filter = {}
        if (query.category) {
            filter.category = query.category
        }
        if (query.inStock !== undefined) {
            filter.stock = query.inStock === 'true' ? { $gt: 0 } : 0
        }

        const products = await productModel.paginate(filter, options)

        const result = {
            status: 'success',
            payload: products.docs,
            totalPages: products.totalPages,
            prevPage: products.prevPage,
            nextPage: products.nextPage,
            page: products.page,
            hasPrevPage: products.hasPrevPage,
            hasNextPage: products.hasNextPage,
            prevLink: products.hasPrevPage ? `/?page=${products.prevPage}&limit=${limit}${query.category ? `&category=${query.category}` : ''}${query.inStock ? `&inStock=${query.inStock}` : ''}${sort ? `&sort=${sort}` : ''}` : null,
            nextLink: products.hasNextPage ? `/?page=${products.nextPage}&limit=${limit}${query.category ? `&category=${query.category}` : ''}${query.inStock ? `&inStock=${query.inStock}` : ''}${sort ? `&sort=${sort}` : ''}` : null
        }

        return result
    } catch (error) {
        throw new Error('Error fetching products')
    }
}

// Endpoint to get products with pagination, sorting, and filtering
productRouter.get('/', async (req, res) => {
    try {
        const { page = 1, limit = 10, sort = '', category = '', inStock = '' } = req.query

        const result = await getPaginatedProducts(req.query, page, limit, sort)

        res.status(200).json(result)
    } catch (error) {
        res.status(500).json({ error: 'Internal Server Error', details: error.message })
    }
})

productRouter.post('/products', async (req, res) => {
    try {
        const { _id, title, description, code, price, stock, category } = req.body

        if (_id) {
            return res.status(400).json({ error: 'You can`t generate the ID, it will be autogenerated upon existing inventory' })
        }
        // This Validates that every field is present before submitting, also if the stock is 0 or less it does not allow to enter a new product
        if (stock <= 0) {
            return res.status(400).json({ error: 'Stock must be greater than 0' })
        } else if (!title || !description || !code || !price || !stock || !category) {
            return res.status(400).json({ error: 'All fields are required but thumbnails' })
        }

        let existingProduct = await productModel.findOne({ title: title })
        if (existingProduct) {
            return res.status(400).json({ error: 'A product with this TITLE already exists, check inventory first' })
        }

        let result = await productModel.create({ title, description, code, price, stock, category })

        res.status(200).send({ result: 'success', payload: result })


    } catch (err) {
        res.status(500).json({ error: 'Internal Server Error', err })
    }
})

productRouter.put('/products/:id', async (req, res) => {
    try {
        const productID = req.params.id
        const newProductInfo = req.body

        if (!newProductInfo.title || !newProductInfo.description || !newProductInfo.code || !newProductInfo.price || !newProductInfo.stock || !newProductInfo.category) {
            return res.status(400).send({ status: 'Error while updating', error: 'missing params' })
        }
        let result = await productModel.updateOne({ _id: productID }, newProductInfo)
        res.status(200).send({ result: 'success', payload: result })

    } catch (err) {
        res.status(500).json({ error: 'Internal Server Error', err })
    }
})

productRouter.delete('/products/:id', async (req, res) => {
    try {
        const productId = req.params.id
        const result = await productModel.findByIdAndDelete(productId)

        if (!result) {
            return res.status(404).json({ error: 'Product not found' })
        }

        res.status(200).json({ message: 'Product deleted successfully', payload: result })
    } catch (err) {
        res.status(500).json({ error: 'Internal Server Error', err });
    }
});

export default productRouter
